<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>Chapter 3 Erste Schritte in R | R für die sozio-ökonomische Forschung</title>
  <meta name="description" content="R Skript in der Version 0.0.0.9001." />
  <meta name="generator" content="bookdown 0.14 and GitBook 2.6.7" />

  <meta property="og:title" content="Chapter 3 Erste Schritte in R | R für die sozio-ökonomische Forschung" />
  <meta property="og:type" content="book" />
  
  
  <meta property="og:description" content="R Skript in der Version 0.0.0.9001." />
  <meta name="github-repo" content="graebnerc/RforSocioEcon" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Chapter 3 Erste Schritte in R | R für die sozio-ökonomische Forschung" />
  
  <meta name="twitter:description" content="R Skript in der Version 0.0.0.9001." />
  

<meta name="author" content="Dr. Claudius Gräbner" />


<meta name="date" content="2019-10-18" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="einrichtung.html"/>
<link rel="next" href="markdown.html"/>
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />











<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">R für die sozioökonomische Forschung</a></li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Willkommen</a><ul>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#anderungshistorie-wahrend-des-semesters"><i class="fa fa-check"></i>Änderungshistorie während des Semesters</a></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#lizenz"><i class="fa fa-check"></i>Lizenz</a></li>
</ul></li>
<li class="chapter" data-level="1" data-path="precons.html"><a href="precons.html"><i class="fa fa-check"></i><b>1</b> Vorbemerkungen</a><ul>
<li class="chapter" data-level="1.1" data-path="precons.html"><a href="precons.html#warum-r"><i class="fa fa-check"></i><b>1.1</b> Warum R?</a></li>
<li class="chapter" data-level="1.2" data-path="precons.html"><a href="precons.html#besonderheiten-von-r"><i class="fa fa-check"></i><b>1.2</b> Besonderheiten von R</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="einrichtung.html"><a href="einrichtung.html"><i class="fa fa-check"></i><b>2</b> Einrichtung</a><ul>
<li class="chapter" data-level="2.1" data-path="einrichtung.html"><a href="einrichtung.html#installation-von-r-und-r-studio"><i class="fa fa-check"></i><b>2.1</b> Installation von R und R-Studio</a></li>
<li class="chapter" data-level="2.2" data-path="einrichtung.html"><a href="einrichtung.html#die-r-studio-oberflache"><i class="fa fa-check"></i><b>2.2</b> Die R Studio Oberfläche</a></li>
<li class="chapter" data-level="2.3" data-path="einrichtung.html"><a href="einrichtung.html#einrichtung-eines-r-projekts"><i class="fa fa-check"></i><b>2.3</b> Einrichtung eines R Projekts</a><ul>
<li class="chapter" data-level="2.3.1" data-path="einrichtung.html"><a href="einrichtung.html#arbeitsverzeichnisse-und-pfade"><i class="fa fa-check"></i><b>2.3.1</b> Arbeitsverzeichnisse und Pfade</a></li>
<li class="chapter" data-level="2.3.2" data-path="einrichtung.html"><a href="einrichtung.html#schritt-1-projektordner-anlegen"><i class="fa fa-check"></i><b>2.3.2</b> Schritt 1: Projektordner anlegen</a></li>
<li class="chapter" data-level="2.3.3" data-path="einrichtung.html"><a href="einrichtung.html#schritt-2-ein-r-studio-projekt-im-projektordner-erstellen"><i class="fa fa-check"></i><b>2.3.3</b> Schritt 2: Ein R-Studio Projekt im Projektordner erstellen</a></li>
<li class="chapter" data-level="2.3.4" data-path="einrichtung.html"><a href="einrichtung.html#schritt-3-relevante-unterordner-erstellen"><i class="fa fa-check"></i><b>2.3.4</b> Schritt 3: Relevante Unterordner erstellen</a></li>
</ul></li>
<li class="chapter" data-level="2.4" data-path="einrichtung.html"><a href="einrichtung.html#abschlieende-bemerkungen"><i class="fa fa-check"></i><b>2.4</b> Abschließende Bemerkungen</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="basics.html"><a href="basics.html"><i class="fa fa-check"></i><b>3</b> Erste Schritte in R</a><ul>
<li class="chapter" data-level="3.1" data-path="basics.html"><a href="basics.html#befehle-in-r-an-den-computer-ubermitteln"><i class="fa fa-check"></i><b>3.1</b> Befehle in R an den Computer übermitteln</a></li>
<li class="chapter" data-level="3.2" data-path="basics.html"><a href="basics.html#objekte-funktionen-und-zuweisungen"><i class="fa fa-check"></i><b>3.2</b> Objekte, Funktionen und Zuweisungen</a></li>
<li class="chapter" data-level="3.3" data-path="basics.html"><a href="basics.html#zwischenbillanz"><i class="fa fa-check"></i><b>3.3</b> Zwischenbillanz</a></li>
<li class="chapter" data-level="3.4" data-path="basics.html"><a href="basics.html#grundlegende-objeke-in-r"><i class="fa fa-check"></i><b>3.4</b> Grundlegende Objeke in R</a><ul>
<li class="chapter" data-level="3.4.1" data-path="basics.html"><a href="basics.html#funktionen"><i class="fa fa-check"></i><b>3.4.1</b> Funktionen</a></li>
<li class="chapter" data-level="3.4.2" data-path="basics.html"><a href="basics.html#vektoren"><i class="fa fa-check"></i><b>3.4.2</b> Vektoren</a></li>
<li class="chapter" data-level="3.4.3" data-path="basics.html"><a href="basics.html#logische-werte-logical"><i class="fa fa-check"></i><b>3.4.3</b> Logische Werte (logical)</a></li>
<li class="chapter" data-level="3.4.4" data-path="basics.html"><a href="basics.html#worter-character"><i class="fa fa-check"></i><b>3.4.4</b> Wörter (character)</a></li>
<li class="chapter" data-level="3.4.5" data-path="basics.html"><a href="basics.html#fehlende-werte-und-null"><i class="fa fa-check"></i><b>3.4.5</b> Fehlende Werte und NULL</a></li>
<li class="chapter" data-level="3.4.6" data-path="basics.html"><a href="basics.html#indizierung-und-ersetzung"><i class="fa fa-check"></i><b>3.4.6</b> Indizierung und Ersetzung</a></li>
<li class="chapter" data-level="3.4.7" data-path="basics.html"><a href="basics.html#nutzliche-funktionen-fur-atomare-vektoren"><i class="fa fa-check"></i><b>3.4.7</b> Nützliche Funktionen für atomare Vektoren</a></li>
<li class="chapter" data-level="3.4.8" data-path="basics.html"><a href="basics.html#matrizen"><i class="fa fa-check"></i><b>3.4.8</b> Matrizen</a></li>
<li class="chapter" data-level="3.4.9" data-path="basics.html"><a href="basics.html#listen"><i class="fa fa-check"></i><b>3.4.9</b> Listen</a></li>
<li class="chapter" data-level="3.4.10" data-path="basics.html"><a href="basics.html#data-frames"><i class="fa fa-check"></i><b>3.4.10</b> Data Frames</a></li>
</ul></li>
<li class="chapter" data-level="3.5" data-path="basics.html"><a href="basics.html#pakete"><i class="fa fa-check"></i><b>3.5</b> Pakete</a></li>
<li class="chapter" data-level="3.6" data-path="basics.html"><a href="basics.html#kurzer-exkurs-zum-einlesen-und-schreiben-von-daten"><i class="fa fa-check"></i><b>3.6</b> Kurzer Exkurs zum Einlesen und Schreiben von Daten</a></li>
</ul></li>
<li class="appendix"><span><b>Appendix</b></span></li>
<li class="chapter" data-level="A" data-path="markdown.html"><a href="markdown.html"><i class="fa fa-check"></i><b>A</b> Eine kurze Einführung in R Markdown</a></li>
<li class="chapter" data-level="B" data-path="refs.html"><a href="refs.html"><i class="fa fa-check"></i><b>B</b> Referenzen</a></li>
<li class="divider"></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Published with bookdown</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">R für die sozio-ökonomische Forschung</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="basics" class="section level1">
<h1><span class="header-section-number">Chapter 3</span> Erste Schritte in R</h1>
<p>Nach diesen (wichtigen) Vorbereitungsschritten wollen wir nun mit dem eigentlichen Programmieren anfangen. Zu diesem Zweck müssen wir uns mit der Syntax von R vertraut machen, also den Regeln, denen wir folgen müssen, wenn wir Code schreiben, damit der Computer versteht, was wir ihm eigentlich in R sagen wollen.</p>
<div id="befehle-in-r-an-den-computer-ubermitteln" class="section level2">
<h2><span class="header-section-number">3.1</span> Befehle in R an den Computer übermitteln</h2>
<p>Grundsätzlich können wir über R Studio auf zwei Arten mit dem Computer “kommunizieren”: über die Konsole direkt, oder indem wir im Skriptbereit ein Skript schreiben und dies dann ausführen.</p>
<p>Als Beispiel für die erste Möglichkeit wollen wir mit Hilfe von R die Zahlen <code>2</code> und <code>5</code> miteinander addieren. Zu diesem Zweick können wir einfach <code>2 + 2</code> in die Konsole eingeben, und den Begehl mit ‘Enter’ an den Computer senden. Da es sich beim Ausdruck <code>2 + 3</code> um korrekten R Code handelt, ‘versteht’ der Computer was wir von uns wollen und gibt uns das entsprechende Ergebnis aus:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="dv">2</span> <span class="op">+</span><span class="st"> </span><span class="dv">3</span></code></pre></div>
<pre><code>#&gt; [1] 5</code></pre>
<p>Auf diese Art und Weise könne wir R als einfachen Taschenrechner verwenden, denn für alle einfachen mathematischen Operationen können wir bestimmte Symbole als Operatoren verwenden. An dieser Stelle sei noch darauf hingewiesen, dass das Symbol <code>#</code> in R einen Kommentar einleitet, das heißt alles was in einer Zeile nach <code>#</code> steht wird vom Computer ignoriert und man kann sich einfach Notizen in seinem Code machen.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="dv">2</span> <span class="op">+</span><span class="st"> </span><span class="dv">2</span> <span class="co"># Addition</span></code></pre></div>
<pre><code>#&gt; [1] 4</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="dv">2</span><span class="op">/</span><span class="dv">2</span> <span class="co"># Division</span></code></pre></div>
<pre><code>#&gt; [1] 1</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="dv">4</span><span class="op">*</span><span class="dv">2</span> <span class="co"># Multiplikation</span></code></pre></div>
<pre><code>#&gt; [1] 8</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="dv">3</span><span class="op">**</span><span class="dv">2</span> <span class="co"># Potenzierung</span></code></pre></div>
<pre><code>#&gt; [1] 9</code></pre>
<p>Alternativ können wir die Befehle in einem Skript aufschreiben, und dieses Skript dann ausführen. Während die Interaktion über die Konsole sinnvoll ist um die Effekte bestimmter Befehle auszuprobieren, bietet sich die Verwendung von Skripten an, wenn wir mit den Befehlen später weiter arbeiten wollen, oder sie anderen Menschen zugänglich zu machen.</p>
<p>Die Berechnungen, die wir bisland durchgeführt haben sind zugegebenermaßen nicht sonderlich spannend. Um fortgeschrittene Operationen in R durchführen und verstehen zu können müssen wir uns zunächst mit den Konzepten von <strong>Objekten</strong>, <strong>Funktionen</strong> und <strong>Zuweisungen</strong> beschäftigen.</p>
</div>
<div id="objekte-funktionen-und-zuweisungen" class="section level2">
<h2><span class="header-section-number">3.2</span> Objekte, Funktionen und Zuweisungen</h2>
<blockquote>
<p>To understand computations in R, two slogans are helpful: Everything that exists is an object. Everything that happens is a function call. —John Chambers</p>
</blockquote>
<p>Mit der Aussage ‘Alles in R ist ein Objekt’ ist gemeint, dass jede Zahl, jede Funktion, oder jeder Buchstabe in R ein Objekt ist, das irgendwo auf dem Speicher Ihres Rechners abgespeichert ist.</p>
<p>In der Berechnung <code>2 + 3</code> ist die Zahl <code>2</code> genauso ein Objekt wie die Zahl <code>3</code> und die Additionsfunktion, die durch den Operator <code>+</code> aufgerufen wird.</p>
<p>Mit der Aussage ‘Alles was in R passiert ist ein Funktionsaufruf’ ist gemeint, dass wenn wir R eine Berechnung durchführen lassen, tun wir dies indem wir eine Funktion aufrufen.</p>
<p><strong>Funktionen</strong> sind Algorithmen, die bestimmte Routinen auf einen <em>Input</em> anwenden und dabei einen <em>Output</em> produzieren. Die Additionsfunktion, die wir in der Berechnung <code>2 + 3</code> aufgerufen haben hat als Input die beiden Zahlen <code>2</code> und <code>3</code> aufgenommen, hat auf sie die Routine der Addition angewandt und als Output die Zahl <code>5</code> ausgegeben. Der Output <code>5</code> ist dabei in R genauso ein Objekt wie die Inputs <code>2</code> und <code>3</code>, sowie die Funktion <code>+</code>.</p>
<p>Ein ‘Problem’ ist, dass R im vorliegenden Falle den Output der Berechnung zwar ausgibt, wir danach aber keinen Zugriff darauf mehr haben:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="dv">2</span> <span class="op">+</span><span class="st"> </span><span class="dv">3</span></code></pre></div>
<pre><code>#&gt; [1] 5</code></pre>
<p>Falls wir den Output weiterverwenden wollen, macht es Sinn, dem Output Objekt einen Namen zu geben, damit wir später wieder darauf zugreifen können. Der Prozess einem Objekt einen Namen zu Geben wird <strong>Zuweisung</strong> oder <strong>Assignment</strong> genannt und durch die Funktion <code>assign</code> vorgenommen:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">assign</span>(<span class="st">&quot;zwischenergebnis&quot;</span>, <span class="dv">2</span> <span class="op">+</span><span class="st"> </span><span class="dv">3</span>)</code></pre></div>
<p>Wir können nun das Ergebnis der Berechnung <code>2 + 3</code> aufrufen, indem wir in R den Namen des Output Objekts eingeben:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">zwischenergebnis</code></pre></div>
<pre><code>#&gt; [1] 5</code></pre>
<p>Da Zuweisungen so eine große Rolle spielen und sehr häufig vorkommen gibt es auch für die Funktion <code>assign</code> eine Kurzschreibweise, nämlich <code>&lt;-</code>. Entsprechend sind die folgenden beiden Befehle äquivalent:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">assign</span>(<span class="st">&quot;zwischenergebnis&quot;</span>, <span class="dv">2</span> <span class="op">+</span><span class="st"> </span><span class="dv">3</span>)
zwischenergebnis &lt;-<span class="st"> </span><span class="dv">2</span> <span class="op">+</span><span class="st"> </span><span class="dv">3</span></code></pre></div>
<p>Entsprechend werden wir Zuweisungen immer mit dem <code>&lt;-</code> Operator durchführen.<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a></p>
<p>Wir können in R nicht beliebig Namen vergeben. Gültige (also: syntaktisch korrekte) Namen …</p>
<ul>
<li>enthalten nur Buchstaben, Zahlen und die Symbole <code>.</code> und <code>_</code></li>
<li>fangen nicht mit <code>.</code> oder einer Zahl an!</li>
</ul>
<p>Zudem gibt es einige Wörter, die schlicht nicht als Name verwendet werden dürgen, z.B. <code>function</code>, <code>TRUE</code>, oder <code>if</code>. Die gesamte Liste verbotener Worte kann mit dem Befehl <code>?Reserved</code> ausgegeben werden.</p>
<p>Wenn man einen Namen vergeben möchte, der nicht mit den gerade formulierten Regeln kompatibel ist, gibt R eine Fehlermeldung aus:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="ot">TRUE</span> &lt;-<span class="st"> </span><span class="dv">5</span></code></pre></div>
<pre><code>#&gt; Error in TRUE &lt;- 5: invalid (do_set) left-hand side to assignment</code></pre>
<p>Zudem sollte man folgendes beachten:</p>
<ul>
<li>Namen sollten kurz und informativ sein; entsprechen ist <code>sample_mean</code> ein guter Name, <code>shit15_2</code> dagegen eher weniger</li>
<li>Man sollte <strong>nie Umlaute in Namen verwenden</strong></li>
<li>Auch wenn möglich, sollte man nie von R bereit gestellte Funktionen überschreiben. Eine Zuweisung wie <code>assign &lt;- 2</code> ist zwar möglich, führt in der Regel aber zu großem Unglück, weil man nicht mehr ganz einfach auf die zugrundeliegende Funktion zurückgreifen kann.</li>
</ul>
<blockquote>
<p><strong>Hinweis</strong>: Alle aktuellen Namenszuweisungen sind im Bereich <code>Environment</code> in R Studio (Nr. 4 in der Abbildung oben) aufgelistet und können durch die Funktion <code>ls()</code> angezeigt werden.</p>
</blockquote>
<blockquote>
<p><strong>Hinweis</strong>: Ein Objekt kann mehrere Namen haben, aber kein Name kann zu mehreren Objekten zeigen, da im Zweifel eine neue Zuweisung die alte Zuweisung überschreibt:</p>
</blockquote>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="dv">2</span> 
y &lt;-<span class="st"> </span><span class="dv">2</span> <span class="co"># Das Objekt 2 hat nun zwei Namen</span>
<span class="kw">print</span>(x)</code></pre></div>
<pre><code>#&gt; [1] 2</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(y)</code></pre></div>
<pre><code>#&gt; [1] 2</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="dv">4</span> <span class="co"># Der Name &#39;x&#39; zeigt nun zum Objekt &#39;4&#39;, nicht mehr zu &#39;2&#39;</span>
<span class="kw">print</span>(x)</code></pre></div>
<pre><code>#&gt; [1] 4</code></pre>
<blockquote>
<p><strong>Hinweis</strong>: Wie Sie bereits bemerkt haben wird nach einer Zuweisung kein Wert sichtbar ausgegeben:</p>
</blockquote>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="dv">2</span> <span class="op">+</span><span class="st"> </span><span class="dv">2</span> <span class="co"># Keine Zuweisung, R gibt das Ergebnis in der Konsole aus</span></code></pre></div>
<pre><code>#&gt; [1] 4</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="dv">2</span> <span class="op">+</span><span class="st"> </span><span class="dv">2</span> <span class="co"># Zuweisung, R gibt das Ergebnis in der Konsole nicht aus</span></code></pre></div>
<blockquote>
<p>Wenn wir das Ergebnis einer Zuweisung in der Konsole ausgeben wollen, können wir entweder das resultierende Objekt aufrufen oder, insbesondere wenn es nicht der letzte Befehl in einer von Befehlen ist, die Funktion <code>print</code> verwenden. Der besseren Übersicht halber können wir auch mit Zeilenumbrüchen arbeiten:</p>
</blockquote>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(x)</code></pre></div>
<pre><code>#&gt; [1] 4</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(
  <span class="dv">2</span><span class="op">*</span><span class="dv">8</span>
  )</code></pre></div>
<pre><code>#&gt; [1] 16</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(<span class="dv">5</span><span class="op">+</span>x)</code></pre></div>
<pre><code>#&gt; [1] 9</code></pre>
</div>
<div id="zwischenbillanz" class="section level2">
<h2><span class="header-section-number">3.3</span> Zwischenbillanz</h2>
<ul>
<li>Wir können Befehle in R Studio an den Computer übermitteln indem wir (a) den R Code in die Konsole schreiben und Enter drücken oder (b) den Code in ein Skript schreiben und dann ausführen</li>
<li>Alles was in R <em>existiert</em> ist ein Objekt, alles was in R <em>passiert</em> ist ein Funktionsaufruf</li>
<li>Wir können einem Objekt mit Hilfe von <code>&lt;-</code> einen Namen geben und dann später wieder aufrufen. Den Prozess der Namensgebung nennen wir <strong>Assignment</strong> und wir können uns alle aktuell von uns vergebenen Namen mit der Funktion <code>ls()</code> anzeigen lassen.</li>
<li>Eine Funktion ist ein Objekt, das auf einen Input eine bestimmte Routine anwendet und einen Output produziert</li>
<li>Die wichtigste Art, Funktionen aufzurufen ist, ihren Namen zu schreiben und danach die Argumente in Klammern anzugeben (Prefix Form, z.B. <code>assign(&quot;x&quot;, 2)</code>)</li>
<li>Gerade bei mathematischen Funktionen wie <code>+</code> und <code>-</code> verwenden wir auch die Infix Form, bei der die Argumente vor und nach dem Funktionsnamen stehen (z.B. <code>2 + 3</code>)</li>
</ul>
<p>An dieser Stelle sei noch auf die Hilfefunktion <code>help()</code> hingewiesen. Falls Sie Informationen über ein Objekt bekommen wollen können Sie so weitere Informationen bekommen. Wenn Sie z.B. genauere Informationen über die Verwendung der Funktion <code>assign</code> erhalten wollen können Sie folgendes eingeben:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">help</span>(assign)
<span class="kw">help</span>(<span class="st">&quot;assign&quot;</span>) <span class="co"># äquivalent</span></code></pre></div>
</div>
<div id="grundlegende-objeke-in-r" class="section level2">
<h2><span class="header-section-number">3.4</span> Grundlegende Objeke in R</h2>
<p>Wir haben bereits gelernt, dass alles was in R existiert ein Objekt ist. Wir haben aber auch schon gelernt, dass es unterschiedliche Typen von Objekten gibt: Zahlen, wie <code>2</code> oder <code>3</code> und Funktionen wie <code>assign</code>.<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a> Tatsächlich gibt es noch viel mehr Arten von Objekten. Ein gutes Verständnis der Objektarten ist Grundvoraussetzung später anspruchsvolle Programmierarufgaben zu lösen. Daher wollen wir uns im folgenden mit den wichtigsten Objektarten in R auseinandersetzen.</p>
<div id="funktionen" class="section level3">
<h3><span class="header-section-number">3.4.1</span> Funktionen</h3>
<p>Wie oben bereits kurz erwähnt handelt es sich bei Funktionen um Algorithmen, die bestimmte Routinen auf einen <em>Input</em> anwenden und dabei einen <em>Output</em> produzieren.</p>
<p>Die Funktion <code>log()</code> zum Beispiel nimmt als Input eine Zahl und gibt als Output den Logarithmus dieser Zahl aus:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">log</span>(<span class="dv">2</span>)</code></pre></div>
<pre><code>#&gt; [1] 0.6931472</code></pre>
<p><strong>Eine Funktion aufrufen</strong></p>
<p>In R gibt es prinzipiell vier verschiedene Arten Funktionen aufzurufen. Nur zwei davon sind allerdings aktuell für uns relevant.</p>
<p>Die bei weitem wichtigste Variante ist die so genannte <em>Prefix-Form</em>. Dies ist die Form, die wir bei der überwältigenden Anzahl von Funktionen verwenden werden. Wir schreiben hier zunächst den Namen der Funktion (im Folgenden Beispiel <code>assign</code>), dann in Klammern und mit Kommata getrennt die Argumente der Funktion (hier der Name <code>test</code> und die Zahl <code>2</code>):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">assign</span>(<span class="st">&quot;test&quot;</span>, <span class="dv">2</span>)</code></pre></div>
<p>Ein hin und wieder auftretende Form ist die so genannte <em>Infix-Form</em>. Hier wird der Funktionsname zwischen die Argumente geschrieben. Dies ist, wie wir oben bereits bemerkt haben, bei vielen mathematischen Funktionen wie <code>+</code>, <code>-</code> oder <code>/</code> der Fall. Streng genommen ist die die Infix-Form aber nur eine <em>Abkürzung</em>, denn jeder Funktionsaufruf in Infix-Form kann auch in Prefix-Form geschrieben werden, wie folgendes Beispiel zeigt:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="dv">2</span> <span class="op">+</span><span class="st"> </span><span class="dv">3</span></code></pre></div>
<pre><code>#&gt; [1] 5</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="st">`</span><span class="dt">+</span><span class="st">`</span>(<span class="dv">2</span>,<span class="dv">3</span>)</code></pre></div>
<pre><code>#&gt; [1] 5</code></pre>
<p><strong>Die Argumente einer Funktion</strong></p>
<p>Die Argumente einer Funktion stellen zum einen den <em>Input</em> für die in der Funktion implementierten Routine dar.</p>
<p>Die Funktion <code>sum</code> zum Beispiel nimmt als Argumente eine beliebige Anzahl an Zahlen (ihr ‘Input’) und berechnet die Summe dieser Zahlen:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">sum</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>)</code></pre></div>
<pre><code>#&gt; [1] 10</code></pre>
<p>Darüber hinaus akzeptiert <code>sum()</code> noch ein <em>optionales Argument</em>, <code>na.rm</code>, welches entweder den Wert <code>TRUE</code> oder <code>FALSE</code> annehmen kann. Wenn wir das Argument nicht explizit spezifizieren nimmt es automatisch <code>FALSE</code> als den Standardwert an.</p>
<p>Dieses optionale Argument ist kein klassischer Input, sondern kontrolliert das genaue Verhalten der Funktion. Im Falle von <code>sum()</code> werden fehlende Werte, so genannte <code>NA</code> (siehe unten) ignoriert bevor die Summe der Inputs gebildet wird wenn <code>na.rm</code> den Wert <code>TRUE</code> hat:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">sum</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="ot">NA</span>) </code></pre></div>
<pre><code>#&gt; [1] NA</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">sum</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="ot">NA</span>, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>) </code></pre></div>
<pre><code>#&gt; [1] 10</code></pre>
<p>Wenn wir wissen wollen, welche Argumente eine Funktion akzeptiert ist es immer eine gute Idee über die Funktion <code>help()</code> einen Blick in die Dokumentation zu werfen!</p>
<p>Im Falle von <code>sum()</code> sehen wir hier sofort, dass die Funktion nehmen den zu addierenden Zahlen ein optionales Argument <code>na.rm</code> akzeptiert, welches den Standardwert <code>FALSE</code> annimmt.</p>
<p><strong>Eigene Funktionen definieren</strong></p>
<p>Sehr häufig möchten wir selbst Funktionen definieren. Das können wir mit dem reservierten Keyword <code>function</code> machen. Als Beispiel wollen wir eine Funktion <code>pythagoras</code> definieren, die als Argumente die Seitenlängen der Katheten eines rechtwinkligen Dreiecks annimmt und über den <a href="https://de.wikipedia.org/wiki/Satz_des_Pythagoras">Satz des Pythagoras</a> die Länge der Hypothenuse bestimmt:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">pythagoras &lt;-<span class="st"> </span><span class="cf">function</span>(a, b){
  hypo_quadrat &lt;-<span class="st"> </span>a<span class="op">**</span><span class="dv">2</span> <span class="op">+</span><span class="st"> </span>b<span class="op">**</span><span class="dv">2</span>
  hypo &lt;-<span class="st"> </span><span class="kw">sqrt</span>(hypo_quadrat) <span class="co"># sqrt() zieht die Quadratwurzel</span>
  <span class="kw">return</span>(hypo)
}</code></pre></div>
<p>Wir definieren eine Funktion durch die Funktion <code>function()</code>. In der Regel beginnen wir die Definition indem wir der zu erstellenden mit einem Namen assoziieren (hier: ‘pythagoras’) damit wir sie später auch verwenden können.</p>
<p>Die Argumente für <code>function</code> sind dann die Argumente, welche die zu definierende Funktion annehmen soll, in diesem Fall <code>a</code> und <code>b</code>. Danach beginnen wir den ‘function body’, also den Code für die Routine, welche die Funktion ausführen soll, mit einer geschweiften Klammer.</p>
<p>Innerhalb des <em>function bodies</em> wird dann die entsprechende Routine implementiert. Alle Namen, die innerhalb des <em>function bodies</em> verwendet werden gehen nach dem Funktionsaufruf verloren:<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a></p>
<p>Am Ende der Routine kann man mit dem Keyword <code>return</code> explizit machen welchen Wert die Funktion als Output ausgeben soll.<a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a> Wenn wir die Funktion nun aufrufen wird die oben definierte Routine ausgeführt:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">pythagoras</span>(<span class="dv">2</span>, <span class="dv">4</span>)</code></pre></div>
<pre><code>#&gt; [1] 4.472136</code></pre>
<p>Es ist immer eine gute Idee, die selbst definierten Funktionen zu dokumentieren - nicht nur wenn wir sie auch anderen zur Verfügung stellen wollen, sondern auch damit wir selbst nach einer möglichen Pause unseren Code noch gut verstehen können. Nichts ist frustrierender als nach einer mehrwöchigen Pause viele Stunden investieren zu müssen, den eigens programmierten Code zu entschlüsseln!</p>
<p>Die Dokumentation von Funktionen kann mit Hilfe von einfachen Kommentaren erfolgen, ich empfehle jedoch sofort sich die <a href="https://r-pkgs.org/man.html#man-functions">hier beschriebenen Konventionen</a> anzugewöhnen. In diesem Falle würde eine Dokumentation unserer Funktion <code>pythagoras</code> folgendermaßen aussehen:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co">#&#39; Berechne die Länge der Hypothenuse in einem rechtwinkligen Dreieck</span>
<span class="co">#&#39; </span>
<span class="co">#&#39; Diese Funktion nimmt als Argumente die Längen der beiden Katheten eines</span>
<span class="co">#&#39;  rechtwinkligen Dreiecks und berechnet daraus die Länge der Hypothenuse.</span>
<span class="co">#&#39; @param a Die Länge der ersten Kathete</span>
<span class="co">#&#39; @param b Die Länge der zweiten Kathete</span>
<span class="co">#&#39; @return Die Länge der Hypothenuse des durch a und b definierten </span>
<span class="co">#&#39;  rechtwinkligen Dreieckst</span>
pythagoras &lt;-<span class="st"> </span><span class="cf">function</span>(a, b){
  hypo_quadrat &lt;-<span class="st"> </span>a<span class="op">**</span><span class="dv">2</span> <span class="op">+</span><span class="st"> </span>b<span class="op">**</span><span class="dv">2</span>
  hypo &lt;-<span class="st"> </span><span class="kw">sqrt</span>(hypo_quadrat) <span class="co"># sqrt() zieht die Quadratwurzel</span>
  <span class="kw">return</span>(hypo)
}</code></pre></div>
<p>Die Dokumentation einer Funktion sollte also zumindest die Parameter und die Art des Outputs erklären.</p>
<p><strong>Gründe für die Verwendung eigener Funktionen</strong></p>
<p>Eigene Funktionen zu definieren ist in der Praxis extrem hilfreich und es ist empfehlenswert Routinen, die mehrere Male verwendet werden grundsätzlich als Funktionen zu schreiben. Dafür gibt es mehrere Gründe:</p>
<ol style="list-style-type: decimal">
<li><strong>Der Code wird kürzer und transparenter</strong> Zwar ist kurzer Code nicht notwendigerweise leichter zu verstehen als langer, aber Funktionen können besonders gut dokumentiert werden (am besten indem man den hier beschriebenen Konventionen folgt).</li>
<li><strong>Funktionen bieten Struktur</strong> Funktionen fassen in der Regel Ihre Vorstellung davon zusammen, wie ein bestimmtes Problem zu lösen ist. Da man sich diese Gedanken nicht ständig neu machen möchte ist es sinnvoll sie einmalig in einer Funktion zusammen zu fassen.</li>
<li><strong>Funktionen erleichtern Korrekturen</strong> Wenn Sie merken, dass Sie in der Implementierung einer Routine einen Fehler gemacht haben müssen Sie im besten Falle nur einmal die Definition der Funktion korrigieren - im schlimmsten Falle müssen sie in ihrem Code nach der Routine suchen und sie in jedem einzelnen Anwendungsfall erneut korrigieren.</li>
</ol>
<p>Es gibt noch viele weitere Gründe dafür, Funktionen häufig zu verwenden. Viele hängen mit dem Entwicklerprinzip <a href="https://de.wikipedia.org/wiki/Don%E2%80%99t_repeat_yourself">DRY</a> zusammen.</p>
</div>
<div id="vektoren" class="section level3">
<h3><span class="header-section-number">3.4.2</span> Vektoren</h3>
<p>Vektoren sind einer der wichtigsten Objettypen in R. Quasi alle Daten mit denen wir in R arbeiten werden als Vektoren behandelt werden.</p>
<p>Was Vektoren angeht gibt es wiederum die wichtige <strong>Unterscheidung von atomaren Vektoren und Listen</strong>. Beide bestehen ihrerseits aus Objekten und sie unterscheiden sich dadurch, dass atomare Vektoren nur aus Objekten des gleichen Typs bestehen können, Listen dagegen auch Objekte unterschiedlichen Typs beinhalten können.</p>
<p>Entsprechend kann jeder atomare Vektor einem Typ zugeordnet werden, je nachdem welchen Typ seine Bestandteile haben. Hier sind insbesondere vier Typen relevant:</p>
<ul>
<li>Logische Werte (<code>logical</code>): es gibt zwei logische Werte, <code>TRUE</code> und <code>FALSE</code>, welche auch mit <code>T</code> oder <code>F</code> abgekürzt werden können</li>
<li>Ganze Zahlen <code>integer</code>: das sollte im Prinzip selbsterklärend sein, allerding müssen den ganzen Zahln in R immer der Buchstabe <code>L</code>folgen, damit die Zahl tatsächlich als ganze Zahl interpretiert wird.<a href="#fn6" class="footnoteRef" id="fnref6"><sup>6</sup></a> Beispiele sind <code>1L</code>, <code>400L</code> oder <code>10L</code>.<br />
</li>
<li>Dezimalzahlen <code>double</code>: auch das sollte selbsterklärend sein; Beispiele wären <code>1.5</code>, <code>0.0</code>, oder <code>-500.32</code>.</li>
<li>Ganze Zahlen und Dezimalzahlen werden häufig unter der Kategorie <code>numeric</code> zusammengefasst. Dies ist in der Praxis aber quasi nie hilfreich und man sollte diese Kategorie möglichst nie verwenden.</li>
<li>Wörter (<code>character</code>): sie sind dadurch gekennzeichnet, dass sie auch Buchstaben enthalten können und am Anfang und Ende ein <code>&quot;</code> haben. Beispiele hier wären <code>&quot;Hallo&quot;</code>, <code>&quot;500&quot;</code> oder <code>&quot;1_2_Drei&quot;</code>.</li>
<li>Es gibt noch zwei weitere besondere ‘Typen’, die strikt gesehen keine atomaren Vektoren darstellen, allerdings in diesem Kontext schon häufig auftauchen: <code>NULL</code>, was strikt genommen ein eigener Datentyp ist und immer die Länge 0 hat, sowie <code>NA</code>, das einen fehlenden Wert darstellt</li>
</ul>
<p>Hieraus ergibt sich folgende Aufteilung für Vektoren:</p>
<p><img src="figures/vector-classification.png" width="80%" style="display: block; margin: auto;" /></p>
<p>Wir werden nun die einzelnen Typen genauer betrachten. Vorher wollen wir jedoch noch die Funktion <code>typeof</code> einführen. Sie hilft uns in der Praxis den Typ eines Objekts herauszufinden. Dafür rufen wir einfach die Funktion <code>typeof</code> mit dem zu untersuchenden Objekt oder dessen Namen auf:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">typeof</span>(2L)</code></pre></div>
<pre><code>#&gt; [1] &quot;integer&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="fl">22.0</span>
<span class="kw">typeof</span>(x)</code></pre></div>
<pre><code>#&gt; [1] &quot;double&quot;</code></pre>
<p>Wir können auch explizit testen ob ein Objekt ein Objekt bestimmten Typs ist. Die generelle Syntax hierfür ist: <code>is.*()</code>, also z.B.:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="fl">1.0</span>
<span class="kw">is.integer</span>(x)</code></pre></div>
<pre><code>#&gt; [1] FALSE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">is.double</span>(x)</code></pre></div>
<pre><code>#&gt; [1] TRUE</code></pre>
<p>Die Funktion gibt als Output also immer einen logischen Wert aus, je nachdem ob die Inputs des entsprechenden Typs sind oder nicht.</p>
<p>Bestimmte Objekte können in einen anderen Typ transformiert werden. Hier spricht man von <code>coercion</code> und die generelle Syntax hierfür ist: <code>as.*()</code>, also z.B.:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> &quot;2&quot;</span>
<span class="kw">print</span>(
  <span class="kw">typeof</span>(x)
)</code></pre></div>
<pre><code>#&gt; [1] &quot;character&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">as.double</span>(x)
<span class="kw">print</span>(
  <span class="kw">typeof</span>(x)
)</code></pre></div>
<pre><code>#&gt; [1] &quot;double&quot;</code></pre>
<p>Allerdings ist eine Transformation nicht immer möglicht:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">as.double</span>(<span class="st">&quot;Hallo&quot;</span>)</code></pre></div>
<pre><code>#&gt; Warning: NAs introduced by coercion</code></pre>
<pre><code>#&gt; [1] NA</code></pre>
<p>Da R nicht weiß wie man aus dem Wort ‘Hallo’ eine Dezimalzahl machen soll, transformiert er das Wort in einen ‘Fehlenden Wert’, der in R als <code>NA</code> bekannt ist und unten noch genauer diskutiert wird.</p>
<p>Für die Grundtypen ergibt sich folgende logische Hierachie an trivialen Transformationen: <code>logical</code> → <code>integer</code> → <code>double</code> → <code>character</code>, d.h. man kann eine Dezimalzahl ohne Probleme in ein Wort transformieren, aber nicht umgekehrt:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="dv">2</span>
y &lt;-<span class="st"> </span><span class="kw">as.character</span>(x)
<span class="kw">print</span>(y)</code></pre></div>
<pre><code>#&gt; [1] &quot;2&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">z &lt;-<span class="st"> </span><span class="kw">as.double</span>(y) <span class="co"># Das funktioniert</span>
<span class="kw">print</span>(z)</code></pre></div>
<pre><code>#&gt; [1] 2</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">k &lt;-<span class="st"> </span><span class="kw">as.double</span>(<span class="st">&quot;Hallo&quot;</span>) <span class="co"># Das nicht</span></code></pre></div>
<pre><code>#&gt; Warning: NAs introduced by coercion</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(k)</code></pre></div>
<pre><code>#&gt; [1] NA</code></pre>
<p>Da nicht immer ganz klar ist wann R bei Transformationen entgegen der gerade eingeführten Hierachie eine Warnung ausgibt und wann nicht sollte man hier immer besondere Vorsicht walten lassen!</p>
<p>Zudem ist bei jeder Transformation Vorsicht geboten, da sie häufig Eigenschaften der Objekte implizit verändert. So führt eine Transformation von einer Dezimalzahl hin zu einer ganzen Zahl teils zu unerwartetem Rundungsverhalten:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="fl">1.99</span>
<span class="kw">as.integer</span>(x)</code></pre></div>
<pre><code>#&gt; [1] 1</code></pre>
<p>Auch führen Transformationen, die der eben genannten Hierachie zuwiderlaufen nicht zwangsweise zu Fehlern, sondern ‘lediglich’ zu unerwarteten Änderungen, die in jedem Fall vermieden werden sollten:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">z &lt;-<span class="st"> </span><span class="kw">as.logical</span>(<span class="dv">99</span>)
<span class="kw">print</span>(z)</code></pre></div>
<pre><code>#&gt; [1] TRUE</code></pre>
<p>Häufig transformieren Funktionen ihre Argumente automatisch, was meistens hilfreich ist, manchmal aber auch gefährlich sein kann:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span>1L <span class="co"># Integer</span>
y &lt;-<span class="st"> </span><span class="fl">2.0</span> <span class="co"># Double</span>
z &lt;-<span class="st"> </span>x <span class="op">+</span><span class="st"> </span>y
<span class="kw">typeof</span>(z)</code></pre></div>
<pre><code>#&gt; [1] &quot;double&quot;</code></pre>
<p>Interessanterweise werden logische Werte ebenfalls transformiert:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="ot">TRUE</span>
y &lt;-<span class="st"> </span><span class="ot">FALSE</span>
z &lt;-<span class="st"> </span>x <span class="op">+</span><span class="st"> </span>y <span class="co"># TRUE wird zu 1, FALSE zu 0</span>
<span class="kw">print</span>(z) </code></pre></div>
<pre><code>#&gt; [1] 1</code></pre>
<p>Daher sollte man immer den Überblick behalten, mit welchen Objekttypen man gerade arbeitet.</p>
<p>Hier noch ein kurzer Überblick zu den Test- und Transformationsbefehlen:</p>
<table>
<thead>
<tr class="header">
<th>Typ</th>
<th>Test</th>
<th>Transformation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>logical</td>
<td><code>is.logical</code></td>
<td><code>as.logical</code></td>
</tr>
<tr class="even">
<td>double</td>
<td><code>is.double</code></td>
<td><code>as.double</code></td>
</tr>
<tr class="odd">
<td>integer</td>
<td><code>is.integer</code></td>
<td><code>as.integer</code></td>
</tr>
<tr class="even">
<td>character</td>
<td><code>is.character</code></td>
<td><code>as.character</code></td>
</tr>
<tr class="odd">
<td>function</td>
<td><code>is.function</code></td>
<td><code>as.function</code></td>
</tr>
<tr class="even">
<td>NA</td>
<td><code>is.na</code></td>
<td>NA</td>
</tr>
<tr class="odd">
<td>NULL</td>
<td><code>is.null</code></td>
<td><code>as.null</code></td>
</tr>
</tbody>
</table>
<p>Ein letzter Hinweis zu <strong>Skalaren</strong>. Unter Skalaren verstehen wir häufig ‘einzelne Zahlen’, z.B. <code>2</code>. Dieses Konzept gibt es in R nicht. <code>2</code> ist ein Vektor der Länge 1. Wir unterscheiden also vom Typ her nicht zwischen einem Vektor, der nur ein oder mehrere Elemente hat.</p>
<p><strong>Hinweis:</strong> Um längere Vektoren zu erstellen, verwenden wir die Funktion <code>c()</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>)
x</code></pre></div>
<pre><code>#&gt; [1] 1 2 3</code></pre>
<p>Dabei können auch Vektoren miteinander verbunden werden:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">3</span> <span class="co"># Shortcut für: x &lt;- c(1, 2, 3)</span>
y &lt;-<span class="st"> </span><span class="dv">4</span><span class="op">:</span><span class="dv">6</span>
z &lt;-<span class="st"> </span><span class="kw">c</span>(x, y)
z</code></pre></div>
<pre><code>#&gt; [1] 1 2 3 4 5 6</code></pre>
<p>Da atomare Vektoren immer nur Objekte des gleichen Typs enthalten können, könnte man erwarten, dass es zu einem Fehler kommt, wenn wir Objete unterschiedlichen Type kombinieren wollen:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="st">&quot;Hallo&quot;</span>)</code></pre></div>
<p>Tatsächlich transformiert R die Objekte allerdings nach der oben beschriebenen Hierachie <code>logical</code> → <code>integer</code> → <code>double</code> → <code>character</code>. Da hier keine Warnung oder kein Fehler ausgegeben wird, sind derlei Transformationen eine gefährliche Fehlerquelle!</p>
<p><strong>Hinweis:</strong> Die Länge eines Vektors kann mit der Funktion <code>length</code> bestimmt werden:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x =<span class="st">  </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>)
len_x &lt;-<span class="st"> </span><span class="kw">length</span>(x)
len_x</code></pre></div>
<pre><code>#&gt; [1] 3</code></pre>
</div>
<div id="logische-werte-logical" class="section level3">
<h3><span class="header-section-number">3.4.3</span> Logische Werte (logical)</h3>
<p>Die logischen Werte <code>TRUE</code> und <code>FALSE</code> sind häufig das Ergebnis von logischen Abfragen, z.B. ‘Ist 2 größer als 1?’. Solche Abfragen kommen in der Forschungspraxis häufig vor und es macht Sinn, sich mit den häufigsten logischen Operatoren vertraut zu machen:</p>
<table>
<thead>
<tr class="header">
<th align="center">Operator</th>
<th align="center">Funktion in R</th>
<th align="left">Beispiel</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">größer</td>
<td align="center"><code>&gt;</code></td>
<td align="left"><code>2&gt;1</code></td>
</tr>
<tr class="even">
<td align="center">kleiner</td>
<td align="center"><code>&lt;</code></td>
<td align="left"><code>2&lt;4</code></td>
</tr>
<tr class="odd">
<td align="center">gleich</td>
<td align="center"><code>==</code></td>
<td align="left"><code>4==3</code></td>
</tr>
<tr class="even">
<td align="center">größer gleich</td>
<td align="center"><code>&gt;=</code></td>
<td align="left"><code>8&gt;=8</code></td>
</tr>
<tr class="odd">
<td align="center">kleiner gleich</td>
<td align="center"><code>&lt;=</code></td>
<td align="left"><code>5&lt;=9</code></td>
</tr>
<tr class="even">
<td align="center">nicht gleich</td>
<td align="center"><code>!=</code></td>
<td align="left"><code>4!=5</code></td>
</tr>
<tr class="odd">
<td align="center">und</td>
<td align="center"><code>&amp;</code></td>
<td align="left"><code>x&lt;90 &amp; x&gt;55</code></td>
</tr>
<tr class="even">
<td align="center">oder</td>
<td align="center"><code>|</code></td>
<td align="left"><code>x&lt;90 | x&gt;55</code></td>
</tr>
<tr class="odd">
<td align="center">entweder oder</td>
<td align="center"><code>xor()</code></td>
<td align="left"><code>xor(2&lt;1, 2&gt;1)</code></td>
</tr>
<tr class="even">
<td align="center">nicht</td>
<td align="center"><code>!</code></td>
<td align="left"><code>!(x==2)</code></td>
</tr>
<tr class="odd">
<td align="center">ist wahr</td>
<td align="center"><code>isTRUE()</code></td>
<td align="left"><code>isTRUE(1&gt;2)</code></td>
</tr>
</tbody>
</table>
<p>Das Ergebnis eines solches Tests ist immer ein logischer Wert:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="dv">4</span>
y &lt;-<span class="st"> </span>x <span class="op">==</span><span class="st"> </span><span class="dv">8</span>
<span class="kw">typeof</span>(y)</code></pre></div>
<pre><code>#&gt; [1] &quot;logical&quot;</code></pre>
<p>Es können auch längere Vektoren getestet werden:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">3</span>
x<span class="op">&lt;</span><span class="dv">2</span></code></pre></div>
<pre><code>#&gt; [1]  TRUE FALSE FALSE</code></pre>
<p>Tests können beliebig miteinander verknüpft werden:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span>1L
x<span class="op">&gt;</span><span class="dv">2</span> <span class="op">|</span><span class="st"> </span>x<span class="op">&lt;</span><span class="dv">2</span> <span class="op">&amp;</span><span class="st"> </span>(<span class="kw">is.double</span>(x) <span class="op">&amp;</span><span class="st"> </span>x<span class="op">!=</span><span class="dv">0</span>)</code></pre></div>
<pre><code>#&gt; [1] FALSE</code></pre>
<p>Da für viele mathematischen Operationen <code>TRUE</code> als die Zahl <code>1</code> interpretiert wird, ist es einfach zu testen wie häufig eine bestimmte Bedingung erfüllt ist:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">50</span> 
smaller_<span class="dv">20</span> &lt;-<span class="st"> </span>x<span class="op">&lt;</span><span class="dv">20</span> 
<span class="kw">print</span>(
  <span class="kw">sum</span>(smaller_<span class="dv">20</span>) <span class="co"># Wie viele Elemente sind kleiner als 20?</span>
  )</code></pre></div>
<pre><code>#&gt; [1] 19</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(
  <span class="kw">sum</span>(smaller_<span class="dv">20</span><span class="op">/</span><span class="kw">length</span>(x)) <span class="co"># Wie hoch ist der Anteil von diesen Elementen?</span>
)</code></pre></div>
<pre><code>#&gt; [1] 0.38</code></pre>
</div>
<div id="worter-character" class="section level3">
<h3><span class="header-section-number">3.4.4</span> Wörter (character)</h3>
<p>Wörter werden in R dadurch gebildet, dass an ihrem Anfang und Ende das Symbol <code>'</code> oder <code>&quot;&quot;</code> steht:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> &quot;Hallo&quot;</span>
<span class="kw">typeof</span>(x)</code></pre></div>
<pre><code>#&gt; [1] &quot;character&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">y &lt;-<span class="st"> &#39;Auf Wiedersehen&#39;</span>
<span class="kw">typeof</span>(y)</code></pre></div>
<pre><code>#&gt; [1] &quot;character&quot;</code></pre>
<p>Wie andere Vektoren können sie mit der Funktion <code>c()</code> verbunden werden:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">z &lt;-<span class="st"> </span><span class="kw">c</span>(x, <span class="st">&quot; und &quot;</span>, y)
z</code></pre></div>
<pre><code>#&gt; [1] &quot;Hallo&quot;           &quot; und &quot;           &quot;Auf Wiedersehen&quot;</code></pre>
<p>Nützlich ist in diesem Zusammenhang die Funktion <code>paste()</code>, die Elemente von mehreren Vektoren in Wörter transformiert und verbindet:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">10</span>
y &lt;-<span class="st"> </span><span class="kw">paste</span>(<span class="st">&quot;Versuch Nr.&quot;</span>, x)
y</code></pre></div>
<pre><code>#&gt;  [1] &quot;Versuch Nr. 1&quot;  &quot;Versuch Nr. 2&quot;  &quot;Versuch Nr. 3&quot;  &quot;Versuch Nr. 4&quot; 
#&gt;  [5] &quot;Versuch Nr. 5&quot;  &quot;Versuch Nr. 6&quot;  &quot;Versuch Nr. 7&quot;  &quot;Versuch Nr. 8&quot; 
#&gt;  [9] &quot;Versuch Nr. 9&quot;  &quot;Versuch Nr. 10&quot;</code></pre>
<p><code>paste()</code> akzeptiert ein optionales Argument <code>sep</code>, mit dem wir den Wert angeben können, der zwischen die zu verbindenden Elemente gesetzt wird:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">tag_nr &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">10</span>
x_axis &lt;-<span class="st"> </span><span class="kw">paste</span>(<span class="st">&quot;Tag&quot;</span>, tag_nr, <span class="dt">sep =</span> <span class="st">&quot;: &quot;</span>)
x_axis</code></pre></div>
<pre><code>#&gt;  [1] &quot;Tag: 1&quot;  &quot;Tag: 2&quot;  &quot;Tag: 3&quot;  &quot;Tag: 4&quot;  &quot;Tag: 5&quot;  &quot;Tag: 6&quot;  &quot;Tag: 7&quot; 
#&gt;  [8] &quot;Tag: 8&quot;  &quot;Tag: 9&quot;  &quot;Tag: 10&quot;</code></pre>
<blockquote>
<p>Hinweis: Hier haben wir ein Beispiel für das so genannte ‘Recycling’ gesehen: da der Vektor <code>c(&quot;Tag&quot;)</code> kürzer war als der Vektor <code>tag_nr</code> wird <code>c(&quot;Tag&quot;)</code> einfach kopiert damit die Operation mit <code>paste()</code> Sinn ergibt. Recycling ist oft praktisch, aber manchmal auch schädlich, nämlich dann, wenn man eigentlich davon ausgeht eine Operation mit zwei gleich langen Vektoren durchzuführen, dies aber tatsächlich nicht tut. In einem solchen Fall führt Recycling dazu, dass keine Fehlermeldung ausgegeben wird.</p>
</blockquote>
</div>
<div id="fehlende-werte-und-null" class="section level3">
<h3><span class="header-section-number">3.4.5</span> Fehlende Werte und NULL</h3>
<p>Fehlende Werte werden in R als <code>NA</code> kodiert. <code>NA</code> erfüllt gerade in statistischen Anwendungen eine wichtige Rolle, da ein bestimmter Platz in einem Vektor aktuell fehlend sein müsste, aber als Platz dennoch existieren muss.</p>
<blockquote>
<p><strong>Beispiel:</strong> Der Vektor <code>x</code> enthält einen logischen Wert, der zeigt ob eine Person die Fragen auf einem Fragebogen richtig beantwortet hat. Wenn die Person die dritte Frage auf dem Fragebogen nicht beantwortet hat, sollte dies durch <code>NA</code> kenntlich gemacht werden. Einfach den Wert komplett wegzulassen macht es im Nachhinein unmöglich festzustellen <em>welche</em> Frage die Person nicht beantwortet hat.</p>
</blockquote>
<p>Die meisten Operationen die <code>NA</code> als einen Input bekommen geben auch als Output <code>NA</code> aus, weil unklar ist wie die Operation mit unterschiedlichen Werten für den fehlenden Wert ausgehen würde:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="dv">5</span> <span class="op">+</span><span class="st"> </span><span class="ot">NA</span></code></pre></div>
<pre><code>#&gt; [1] NA</code></pre>
<p>Einzige Ausnahmen sind Operationen, die undabhängig vom fehlenden Wert einen bestimmten Wert annehmen:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="ot">NA</span> <span class="op">|</span><span class="st"> </span><span class="ot">TRUE</span> <span class="co"># Gibt immer TRUE, unabhängig vom Wert für NA</span></code></pre></div>
<pre><code>#&gt; [1] TRUE</code></pre>
<p>Um zu testen ob ein Vektor <code>x</code> fehlende Werte enthält sollte die Funktion <code>is.na</code> verwendet werden, und nicht etwa der Ausdruck <code>x==NA</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="ot">NA</span>, <span class="dv">5</span>, <span class="ot">NA</span>, <span class="dv">10</span>)
<span class="kw">print</span>(
  x <span class="op">==</span><span class="st"> </span><span class="ot">NA</span> <span class="co"># Unklar da man nicht weiß ob alle NA für den gleichen Wert stehen</span>
  )</code></pre></div>
<pre><code>#&gt; [1] NA NA NA NA</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(
  <span class="kw">is.na</span>(x)
)</code></pre></div>
<pre><code>#&gt; [1]  TRUE FALSE  TRUE FALSE</code></pre>
<p>Wenn eine Operation einen nicht zu definierenden Wert ausgibt, ist das Ergebnis nicht <code>NA</code> sondern <code>NaN</code> (<em>not a number</em>):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="dv">0</span> <span class="op">/</span><span class="st"> </span><span class="dv">0</span></code></pre></div>
<pre><code>#&gt; [1] NaN</code></pre>
<p>Eine weitere Besonderheit ist <code>NULL</code>, welches in der Regel als Vektor der Länge 0 gilt, aber häufig zu besonderen Zwecken verwendet wird:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="ot">NULL</span>
<span class="kw">length</span>(x)</code></pre></div>
<pre><code>#&gt; [1] 0</code></pre>
</div>
<div id="indizierung-und-ersetzung" class="section level3">
<h3><span class="header-section-number">3.4.6</span> Indizierung und Ersetzung</h3>
<p>Einzelne Elemente von atomare Vektoren können mit eckigen Klammern extrahiert werden:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">6</span>)
x[<span class="dv">1</span>]</code></pre></div>
<pre><code>#&gt; [1] 2</code></pre>
<p>Auf diese Weise können auch bestimmte Elemente modifiziert werden:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">6</span>)
x[<span class="dv">2</span>] &lt;-<span class="st"> </span><span class="dv">99</span>
x</code></pre></div>
<pre><code>#&gt; [1]  2 99  6</code></pre>
<p>Es kann auch mehr als ein Element extrahiert werden:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x[<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>]</code></pre></div>
<pre><code>#&gt; [1]  2 99</code></pre>
<p>Negative Indizes sind auch möglich, diese eliminieren die entsprechenden Elemente:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x[<span class="op">-</span><span class="dv">1</span>]</code></pre></div>
<pre><code>#&gt; [1] 99  6</code></pre>
<p>Um das letzte Element eines Vektors zu bekommen verwendet man einen Umweg über die Funktion <code>length()</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x[<span class="kw">length</span>(x)]</code></pre></div>
<pre><code>#&gt; [1] 6</code></pre>
</div>
<div id="nutzliche-funktionen-fur-atomare-vektoren" class="section level3">
<h3><span class="header-section-number">3.4.7</span> Nützliche Funktionen für atomare Vektoren</h3>
<p>Hier sollten nur eingige Funktionen erwähnt werden, die im Kontext von atomaren Vektoren besonders praktisch sind,<a href="#fn7" class="footnoteRef" id="fnref7"><sup>7</sup></a> inbesondere wenn es darum geht solche Vektoren herzustellen, bzw. Rechenoperationen mit ihnen durchzuführen.</p>
<p><strong>Herstellung von atomaren Vektoren</strong>:</p>
<p>Eine Sequenz ganzer Zahlen wird in der Regel sehr häufig gebraucht. Entsprechend gibt es den hilfreichen Shortcut<code>:</code></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">10</span>
x</code></pre></div>
<pre><code>#&gt;  [1]  1  2  3  4  5  6  7  8  9 10</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">y &lt;-<span class="st"> </span><span class="dv">10</span><span class="op">:</span><span class="dv">1</span>
y</code></pre></div>
<pre><code>#&gt;  [1] 10  9  8  7  6  5  4  3  2  1</code></pre>
<p>Häufig möchten wir jedoch eine kompliziertere Sequenz bauen. In dem Fall hilft uns die allgemeinere Funktion <code>seq()</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="dv">1</span>, <span class="dv">10</span>, <span class="dt">by =</span> <span class="fl">0.5</span>)
<span class="kw">print</span>(x)</code></pre></div>
<pre><code>#&gt;  [1]  1.0  1.5  2.0  2.5  3.0  3.5  4.0  4.5  5.0  5.5  6.0  6.5  7.0  7.5
#&gt; [15]  8.0  8.5  9.0  9.5 10.0</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">y &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="dv">2</span>, <span class="dv">8</span>, <span class="dt">length.out =</span> <span class="dv">4</span>)
<span class="kw">print</span>(y)</code></pre></div>
<pre><code>#&gt; [1] 2 4 6 8</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">z &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="dv">10</span>, <span class="dv">25</span>, <span class="dt">along.with =</span> y)
<span class="kw">print</span>(z)</code></pre></div>
<pre><code>#&gt; [1] 10 15 20 25</code></pre>
<p>Auch häufig möchten wir einen bestimmten Wert wiederholen. Das geht mit der Funktion <code>rep</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="ot">NA</span>, <span class="dv">5</span>)
<span class="kw">print</span>(x)</code></pre></div>
<pre><code>#&gt; [1] NA NA NA NA NA</code></pre>
<p><strong>Rechenoperationen</strong></p>
<p>Es gibt eine Reihe von Operationen, die wir sehr häufig gemeinsam mit Vektoren anwenden. Häufig interessiert und die <strong>Länge</strong> eines Vektors. Dafür können wir die Funktion <code>length()</code> verwenden:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>)
<span class="kw">length</span>(x)</code></pre></div>
<pre><code>#&gt; [1] 4</code></pre>
<p>Wenn wir den <strong>größten</strong> oder <strong>kleinsten Wert</strong> eines Vektors erfahren möchten geht das mit den Funktionen <code>min()</code> und <code>max()</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">min</span>(x)</code></pre></div>
<pre><code>#&gt; [1] 1</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">max</span>(x)</code></pre></div>
<pre><code>#&gt; [1] 4</code></pre>
<p>Beide Funktionen besitzen ein optionales Argument <code>na.rm</code>, das entweder <code>TRUE</code> oder <code>FALSE</code> sein kann. Im Fallse von <code>TRUE</code> werden alle <code>NA</code> Werte für die Rechenoperation entfernt:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">y &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="ot">NA</span>)
<span class="kw">min</span>(y)</code></pre></div>
<pre><code>#&gt; [1] NA</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">min</span>(y, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)</code></pre></div>
<pre><code>#&gt; [1] 1</code></pre>
<p>Den <strong>Mittelwert</strong> bzw die <strong>Varianz/Standardabweichung</strong> der Elemente bekommen wir mit <code>mean()</code>, <code>var()</code>, bzw. <code>sd()</code>, wobei alle Funktionen auch das optionale Argument <code>na.rm</code> akzeptieren:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">mean</span>(x)</code></pre></div>
<pre><code>#&gt; [1] 2.5</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">var</span>(y)</code></pre></div>
<pre><code>#&gt; [1] NA</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">var</span>(y, <span class="dt">na.rm =</span> T)</code></pre></div>
<pre><code>#&gt; [1] 1.666667</code></pre>
<p>Ebenfalls häufig sind wir an der <strong>Summe</strong>, bzw, dem <strong>Produkt</strong> aller Elemente des Vektors interessiert. <code>sum()</code> und <code>prod</code> helfen weiter und auch sie kennen das optionale Argument <code>na.rm</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">sum</span>(x)</code></pre></div>
<pre><code>#&gt; [1] 10</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">prod</span>(y, <span class="dt">na.rm =</span> T)</code></pre></div>
<pre><code>#&gt; [1] 24</code></pre>
</div>
<div id="matrizen" class="section level3">
<h3><span class="header-section-number">3.4.8</span> Matrizen</h3>
<p><strong>Erstellen von Matrizen</strong></p>
<p>Matrizen werden mit der Funktion <code>matrix()</code>erstellt. Diese Funktion nimmt als erstes Argument die Elemente der Matrix und dann die Spezifikation der Anzahl von Zeilen (<code>nrow</code>) und/oder der Anzahl von Spalten (<code>ncol</code>):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m_<span class="dv">1</span> &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">11</span><span class="op">:</span><span class="dv">20</span>, <span class="dt">nrow =</span> <span class="dv">5</span>)
m_<span class="dv">1</span></code></pre></div>
<pre><code>#&gt;      [,1] [,2]
#&gt; [1,]   11   16
#&gt; [2,]   12   17
#&gt; [3,]   13   18
#&gt; [4,]   14   19
#&gt; [5,]   15   20</code></pre>
<p>Wie können die Zeilen, Spalten und einzelne Werte folgendermaßen extrahieren und ggf. Ersetzungen vornehmen:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m_<span class="dv">1</span>[,<span class="dv">1</span>] <span class="co"># Erste Spalte</span></code></pre></div>
<pre><code>#&gt; [1] 11 12 13 14 15</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m_<span class="dv">1</span>[<span class="dv">1</span>,] <span class="co"># Erste Zeile</span></code></pre></div>
<pre><code>#&gt; [1] 11 16</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m_<span class="dv">1</span>[<span class="dv">2</span>,<span class="dv">2</span>] <span class="co"># Element [2,2]</span></code></pre></div>
<pre><code>#&gt; [1] 17</code></pre>
<p><strong>Matrizenalgebra</strong></p>
<p>Matrizenalgebra spielt in vielen statistischen Anwendungen eine wichtige Rolle. In R ist es sehr einfach die typischen Rechenoperationen für Matrizen zu implementieren. Hier nur ein paar Beispiele, für die wir die folgenden Matrizen verwenden:</p>
<p><span class="math display">\[A = \left( 
\begin{array}{rrr}                                
1 &amp; 6 \\                                               
5 &amp; 3 \\                                               
\end{array}
\right) \quad B = \left( 
\begin{array}{rrr}                                
0 &amp; 2 \\                                               
4 &amp; 8 \\                                               
\end{array}\right)\]</span></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">matrix_a &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">3</span>), <span class="dt">ncol =</span> <span class="dv">2</span>)
matrix_b &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">4</span>,<span class="dv">2</span>,<span class="dv">8</span>), <span class="dt">ncol =</span> <span class="dv">2</span>)</code></pre></div>
<p>Skalar-Addition: <span class="math display">\[4+\boldsymbol{A}=
\left( 
\begin{array}{rrr}                                
4+a_{11} &amp; 4+a_{21} \\                                               
4+a_{12} &amp; 4+a_{22} \\                                               
\end{array}
\right)\]</span></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="dv">4</span><span class="op">+</span>matrix_a</code></pre></div>
<pre><code>#&gt;      [,1] [,2]
#&gt; [1,]    5   10
#&gt; [2,]    9    7</code></pre>
<p>Matrizen-Addition: <span class="math display">\[\boldsymbol{A}+\boldsymbol{B}=
\left(
\begin{array}{rrr}                                
a_{11} + b_{11} &amp; a_{21} + b_{21}\\                                               
a_{12} + b_{12} &amp; a_{22} + b_{22}\\                                               
\end{array}
\right)\]</span></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">matrix_a <span class="op">+</span><span class="st"> </span>matrix_b</code></pre></div>
<pre><code>#&gt;      [,1] [,2]
#&gt; [1,]    1    8
#&gt; [2,]    9   11</code></pre>
<p>Skalar-Multiplikation: <span class="math display">\[2\cdot\boldsymbol{A}=
\left( 
\begin{array}{rrr}                                
2\cdot a_{11} &amp; 2\cdot a_{21} \\                                               
2\cdot a_{12} &amp; 2\cdot a_{22} \\                                               
\end{array}
\right)\]</span></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="dv">2</span><span class="op">*</span>matrix_a</code></pre></div>
<pre><code>#&gt;      [,1] [,2]
#&gt; [1,]    2   12
#&gt; [2,]   10    6</code></pre>
<p>Elementenweise Matrix Multiplikation (auch ‘Hadamard-Produkt’): <span class="math display">\[\boldsymbol{A}\odot\boldsymbol{B}=
\left(
\begin{array}{rrr}                                
a_{11}\cdot b_{11} &amp; a_{21}\cdot b_{21}\\                                               
a_{12}\cdot b_{12} &amp; a_{22}\cdot b_{22}\\                                               
\end{array}
\right)\]</span></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">matrix_a <span class="op">*</span><span class="st"> </span>matrix_b</code></pre></div>
<pre><code>#&gt;      [,1] [,2]
#&gt; [1,]    0   12
#&gt; [2,]   20   24</code></pre>
<p>Matrizen-Multiplikation: <span class="math display">\[\boldsymbol{A}\cdot\boldsymbol{B}=
\left(
\begin{array}{rrr}                                
a_{11}\cdot b_{11} + a_{12}\cdot b_{21} &amp; a_{11}\cdot b_{21}+a_{12}\cdot b_{22}\\                     a_{21}\cdot b_{11} + a_{22}\cdot b_{21} &amp; a_{21}\cdot b_{12}+a_{22}\cdot b_{22}\\                     
\end{array}
\right)
\]</span></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">matrix_a <span class="op">%*%</span><span class="st"> </span>matrix_b</code></pre></div>
<pre><code>#&gt;      [,1] [,2]
#&gt; [1,]   24   50
#&gt; [2,]   12   34</code></pre>
<p>Die Inverse einer Matrix <span class="math inline">\(\boldsymbol{A}\)</span>, <span class="math inline">\(\boldsymbol{A}^{-1}\)</span>, ist definiert sodass gilt <span class="math display">\[\boldsymbol{A}\boldsymbol{A}^{-1}=\boldsymbol{I}\]</span> Sie kann in R mit der Funktion <code>solve()</code> identifiziert werden:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">solve</span>(matrix_a)</code></pre></div>
<pre><code>#&gt;            [,1]        [,2]
#&gt; [1,] -0.1111111  0.22222222
#&gt; [2,]  0.1851852 -0.03703704</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">matrix_a <span class="op">%*%</span><span class="st"> </span><span class="kw">solve</span>(matrix_a)</code></pre></div>
<pre><code>#&gt;      [,1]         [,2]
#&gt; [1,]    1 2.775558e-17
#&gt; [2,]    0 1.000000e+00</code></pre>
<p>Die minimalen Abweichungen sind auf machinelle Rundungsfehler zurückzuführen und treten häufig auf.</p>
<p>Es gibt im Internet zahlreiche gute Überblicksartikel zum Thema Matrizenalgebra in R, z.B. <a href="https://www.statmethods.net/advstats/matrix.html">hier</a> oder in größerem Umfang <a href="https://www.math.uh.edu/~jmorgan/Math6397/day13/LinearAlgebraR-Handout.pdf">hier</a>.</p>
</div>
<div id="listen" class="section level3">
<h3><span class="header-section-number">3.4.9</span> Listen</h3>
<p>Im Gegensatz zu atomaren Vektoren können Listen Objekte verschiedenen Typs enthalten. Sie werden mit der Funktion <code>list()</code> erstellt:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">l_<span class="dv">1</span> &lt;-<span class="st"> </span><span class="kw">list</span>(
  <span class="st">&quot;a&quot;</span>,
  <span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>),
  <span class="ot">FALSE</span>
)
<span class="kw">typeof</span>(l_<span class="dv">1</span>)</code></pre></div>
<pre><code>#&gt; [1] &quot;list&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">l_<span class="dv">1</span></code></pre></div>
<pre><code>#&gt; [[1]]
#&gt; [1] &quot;a&quot;
#&gt; 
#&gt; [[2]]
#&gt; [1] 1 2 3
#&gt; 
#&gt; [[3]]
#&gt; [1] FALSE</code></pre>
<p>Wir können Listen mit der Funktion <code>str()</code> inspizieren. In diesem Fall erhalten wir unmittelbar Informationen über die Art der Elemente:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str</span>(l_<span class="dv">1</span>)</code></pre></div>
<pre><code>#&gt; List of 3
#&gt;  $ : chr &quot;a&quot;
#&gt;  $ : num [1:3] 1 2 3
#&gt;  $ : logi FALSE</code></pre>
<p>Die einzelnen Elemente einer Liste können auch benannt werden:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">l_<span class="dv">2</span> &lt;-<span class="st"> </span><span class="kw">list</span>(
  <span class="st">&quot;erstes_element&quot;</span> =<span class="st"> &quot;a&quot;</span>,
  <span class="st">&quot;zweites_element&quot;</span> =<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>),
  <span class="st">&quot;drittes_element&quot;</span> =<span class="st"> </span><span class="ot">FALSE</span>
)</code></pre></div>
<p>Die Namen aller Elemente in der Liste erhalten wir mit der Funktion <code>names()</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">names</span>(l_<span class="dv">2</span>)</code></pre></div>
<pre><code>#&gt; [1] &quot;erstes_element&quot;  &quot;zweites_element&quot; &quot;drittes_element&quot;</code></pre>
<p>Um einzelne Elemente einer Liste auszulesen müssen wir <code>[[</code> anstatt <code>[</code> verwemden. Wir können dann entweder Elemente nach ihrer Position oder ihren Namen auswählen:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">l_<span class="dv">2</span>[[<span class="dv">1</span>]]</code></pre></div>
<pre><code>#&gt; [1] &quot;a&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">l_<span class="dv">2</span>[[<span class="st">&quot;erstes_element&quot;</span>]]</code></pre></div>
<pre><code>#&gt; [1] &quot;a&quot;</code></pre>
</div>
<div id="data-frames" class="section level3">
<h3><span class="header-section-number">3.4.10</span> Data Frames</h3>
<p>Der <code>data.frame</code> ist eine besondere Art von Liste und ist der in ein in der Datenanalyse regelmäßig auftretender Datentyp. Gegensatz zu einer normalen Liste müssen bei einem <code>data.frame</code> alle Elemente die gleiche Länge aufweisen. Das heißt man kann sich einen <code>data.frame</code> als eine rechteckige Liste vorstellen.</p>
<p>Wegen der engen Verwandschaft können wir einen <code>data.frame</code> direkt aus einer Liste erstellen indem wir die Funktion <code>as.data.frame()</code> verwenden:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">l_<span class="dv">3</span> &lt;-<span class="st"> </span><span class="kw">list</span>(
  <span class="st">&quot;a&quot;</span> =<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">3</span>,
  <span class="st">&quot;b&quot;</span> =<span class="st"> </span><span class="dv">4</span><span class="op">:</span><span class="dv">6</span>,
  <span class="st">&quot;c&quot;</span> =<span class="st"> </span><span class="dv">7</span><span class="op">:</span><span class="dv">9</span>
)
df_<span class="dv">3</span> &lt;-<span class="st"> </span><span class="kw">as.data.frame</span>(l_<span class="dv">3</span>)</code></pre></div>
<p>Wenn wir R nach dem Typ von <code>df_3</code> sehen wir, dass es sich weiterhin um eine Liste handelt:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">typeof</span>(df_<span class="dv">3</span>)</code></pre></div>
<pre><code>#&gt; [1] &quot;list&quot;</code></pre>
<p>Allerdings können wir testen ob <code>df_3</code> ein <code>data.frame</code> ist indem wir <code>is.data.frame</code> benutzen:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">is.data.frame</span>(df_<span class="dv">3</span>)</code></pre></div>
<pre><code>#&gt; [1] TRUE</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">is.data.frame</span>(l_<span class="dv">3</span>)</code></pre></div>
<pre><code>#&gt; [1] FALSE</code></pre>
<p>Wenn wir <code>df_3</code> ausgeben sehen wir unmittelbar den Unterschied zu klassischen Liste:<a href="#fn8" class="footnoteRef" id="fnref8"><sup>8</sup></a></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">l_<span class="dv">3</span></code></pre></div>
<pre><code>#&gt; $a
#&gt; [1] 1 2 3
#&gt; 
#&gt; $b
#&gt; [1] 4 5 6
#&gt; 
#&gt; $c
#&gt; [1] 7 8 9</code></pre>
<p>Die andere Möglichkeit einen <code>data.frame</code> zu erstellen ist direkt über die Funktion <code>data.frame()</code>, wobei es hier in der Regel ratsam ist das optionale Argument <code>stringsAsFactors</code> auf <code>FALSE</code> zu setzen, da sonst Wörter in so genannte Faktoren umgewandelt werden:<a href="#fn9" class="footnoteRef" id="fnref9"><sup>9</sup></a></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">df_<span class="dv">4</span> &lt;-<span class="st"> </span><span class="kw">data.frame</span>(
  <span class="st">&quot;gender&quot;</span> =<span class="st"> </span><span class="kw">c</span>(<span class="kw">rep</span>(<span class="st">&quot;male&quot;</span>, <span class="dv">3</span>), <span class="kw">rep</span>(<span class="st">&quot;remale&quot;</span>, <span class="dv">2</span>)),
  <span class="st">&quot;height&quot;</span> =<span class="st"> </span><span class="kw">c</span>(<span class="dv">89</span>, <span class="dv">75</span>, <span class="dv">80</span>, <span class="dv">66</span>, <span class="dv">50</span>),
  <span class="dt">stringsAsFactors =</span> <span class="ot">FALSE</span>
)
df_<span class="dv">4</span></code></pre></div>
<pre><code>#&gt;   gender height
#&gt; 1   male     89
#&gt; 2   male     75
#&gt; 3   male     80
#&gt; 4 remale     66
#&gt; 5 remale     50</code></pre>
<p>Data frames sind das klassische Objekt um eingelesene Daten zu repräsentieren. Wenn Sie sich z.B. Daten zum BIP in Deutschland aus dem Internet runterladen und diese Daten dann in R einlesen, werden diese Daten zunächst einmal als <code>data.frame</code> repräsentiert.<a href="#fn10" class="footnoteRef" id="fnref10"><sup>10</sup></a> Diese Repräsentation erlaubt dann eine einfache Analyse und Manipulation der Daten.</p>
<p>Zwar gibt es eine eigene Vorlesung zur Bearbeitung von Daten, wir wollen aber schon hier einige zentrale Befehle im Zusammenhang von Data Frames einführen.</p>
<p>Joer sei jedoch schon angemerkt, dass um Zeilen, Spalten oder einzelne Elemente auszuwählen verwenden die gleichen Befehle wie bei Matrizen verwendet werden können:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">df_<span class="dv">4</span>[<span class="dv">1</span>] <span class="co"># erste Spalte</span></code></pre></div>
<pre><code>#&gt;   gender
#&gt; 1   male
#&gt; 2   male
#&gt; 3   male
#&gt; 4 remale
#&gt; 5 remale</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">df_<span class="dv">4</span>[, <span class="dv">2</span>] <span class="co"># Werte der zweiten Spalte</span></code></pre></div>
<pre><code>#&gt; [1] 89 75 80 66 50</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">df_<span class="dv">4</span>[[<span class="st">&quot;gender&quot;</span>]] <span class="co"># Abfrage funktioniert auch mit Spaltennamen</span></code></pre></div>
<pre><code>#&gt; [1] &quot;male&quot;   &quot;male&quot;   &quot;male&quot;   &quot;remale&quot; &quot;remale&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">df_<span class="dv">4</span>[<span class="st">&quot;gender&quot;</span>] <span class="co"># [ gibt als Output einen Data Frame</span></code></pre></div>
<pre><code>#&gt;   gender
#&gt; 1   male
#&gt; 2   male
#&gt; 3   male
#&gt; 4 remale
#&gt; 5 remale</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">df_<span class="dv">4</span>[<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>, ] <span class="co"># Die ersten beiden Zeilen</span></code></pre></div>
<pre><code>#&gt;   gender height
#&gt; 1   male     89
#&gt; 2   male     75</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">df_<span class="dv">4</span>[<span class="dv">2</span>, <span class="dv">2</span>] <span class="co"># Zweite Wert der zweiten Spalte</span></code></pre></div>
<pre><code>#&gt; [1] 75</code></pre>
<p>Dies können wir uns zu Nutze machen um den Typ der einzelnen Spalten herauszufinden:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">typeof</span>(df_<span class="dv">4</span>[[<span class="st">&quot;gender&quot;</span>]])</code></pre></div>
<pre><code>#&gt; [1] &quot;character&quot;</code></pre>
</div>
</div>
<div id="pakete" class="section level2">
<h2><span class="header-section-number">3.5</span> Pakete</h2>
<p>Bei Paketen handelt es sich eine Kombination aus R Code, Daten, Dokumentationen und Tests. Sie sind der beste Weg, reproduzierbaren Code zu erstellen und frei zugänglich zu machen. Zwar werden Pakete häufig der Öffentlichkeit zugänglich gemacht, z.B. über GitHub oder CRAN. Es ist aber genauso hilfreich, Pakete für den privaten Gerbrauch zu schreiben, z.B. um für bestimmte Routinen Funktionen zu programmieren, zu dokumentieren und in verschiedenen Projekten verfügbar zu machen.<a href="#fn11" class="footnoteRef" id="fnref11"><sup>11</sup></a></p>
<p>Die Tatsache, dass viele Menschen statistische Probleme lösen indem sie bestimmte Routinen entwickeln, diese dann generalisieren und über Pakete der ganzen R Community frei verfügbar machen, ist einer der Hauptgründe für den Erfolg und die breite Anwendbarkeit von R.</p>
<p>Wenn man R startet haben wir Zugriff eine eine gewisse Anzahl von Funktionen, vordefinierten Variablen und Datensätzen. Die Gesamtheit dieser Objekte wird in der Regel <code>base R</code> genannt, weil wir alle Funktionalitäten ohne weiteres nutzen können.</p>
<p>Die Funktion <code>assign</code>, zum Beispiel, ist Teil von <code>base R</code>: wir starten R und können Sie ohne weiteres verwenden.</p>
<p>Im Prinzip kann so gut wie jedwede statistische Prozedur in <code>base R</code> implementiert werden. Dies ist aber häufig zeitaufwendig und fehleranfällig: wie wir am Beispiel von Funktionen gelernt haben, sollten häufig verwendete Routinen im Rahmen von einer Funktion implementiert werden, die dann immer wieder angewendet werden kann. Das reduziert nicht nur Fehler, sondern macht den Code besser verständlich.</p>
<p>Pakete folgen dem gleichn Prinzip, nur tragen sie die Idee noch weiter: hier wollen wir die Funktionen auch über ein einzelnes R Projekt hinaus nutzbar machen, sodass sie nicht in jedem Projekt neu definiert werden müssen, sondern zentral nutzbar gemacht und dokumentiert werden.</p>
<p>Um ein Paket in R zu nutzen muss es zunächst installiert werden. Für Pakete, die auf der zentralen R Pakete Plattform CRAN verfügbar sind, geht dies mit der Funktion <code>install.packages</code>. Wenn wir z.B. das Paket <code>data.table</code> installieren wollen geht das mit dem folgenden Befehl:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">install.packages</span>(<span class="st">&quot;data.table&quot;</span>)</code></pre></div>
<p>Das Paket <code>data.table</code> enthält viele Objekte, welche die Arbeit mit großen Datensätzen enorm erleichtern. Darunter ist eine verbesserte Version des <code>data.frame</code>, der <code>data.table</code>. Wir können einen <code>data.frame</code> mit Hilfe der Funktion <code>as.data.table()</code> in einen <code>data.table</code> umwandeln.</p>
<p>Allerdings haben wir selbst nach erfolgreicher Installation von <code>data.table</code> nicht direkt Zugriff auf diese Funktion:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">data.frame</span>(
  <span class="dt">a=</span><span class="dv">1</span><span class="op">:</span><span class="dv">5</span>,
  <span class="dt">b=</span><span class="dv">21</span><span class="op">:</span><span class="dv">25</span>
)
<span class="kw">as.data.table</span>(x)</code></pre></div>
<pre><code>#&gt; Error in as.data.table(x): could not find function &quot;as.data.table&quot;</code></pre>
<p>Wir haben zwei Möglichkeiten auf die Objekte im Paket <code>data.table</code> zuzugreifen: zum einen können wir mit dem Operator <code>::</code> arbeiten:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">y &lt;-<span class="st"> </span>data.table<span class="op">::</span><span class="kw">as.data.table</span>(x)
y</code></pre></div>
<pre><code>#&gt;    a  b
#&gt; 1: 1 21
#&gt; 2: 2 22
#&gt; 3: 3 23
#&gt; 4: 4 24
#&gt; 5: 5 25</code></pre>
<p>Wir schreiben also den Namen des Pakets, direkt gefolgt von <code>::</code> und dann den Namen des Objets aus dem Paket, das wir vewendent wollen.</p>
<p>Zwar ist das der transparenteste und sauberste Weg auf Objekte aus anderen Paketen zuzugreifen, allerdings kann es auch nervig sein wenn man häufig oder sehr viele Objekte aus dem gleichen Paket verwendet. Wir können alle Objekte eines Paketes direkt zugänglich machen indem wir die Funktion <code>library()</code> verwenden.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(data.table)
y &lt;-<span class="st"> </span><span class="kw">as.data.table</span>(x)</code></pre></div>
<p>Der Übersicht halber sollte das für alle in einem Skript verwendeten Pakete ganz am Anfang des Skripts gemacht werden. So sieht man auch unmittelbar welche Pakete für das Skript installiert sein müssen.</p>
<p>Grundsätzlich sollte man in jedem Skript nur die Pakete mit <code>library()</code> einlesen, die auch tatsächlich verwendet werden. Ansonsten lädt man unnötigerweise viele Objekte und verliert den Überblick woher eine bestimmte Funktion eigentlich kommt. Außerdem ist es schwieriger für andere das Skript zu verwenden, weil unter Umständen viele Pakete unnötigerweise installiert werden müssen.</p>
<p>Da Pakete denzentral von verschiedensten Menschen hergestellt werden besteht die Gefahr, dass Objekte in unterschiedlichen Paketen den gleichen Namen bekommen. Da in R ein Name nur zu einem Objekt gehören kann, werden beim Einladen mehrerer Pakete eventuell Namen überschrieben, oder ‘maskiert’. Dies wird am Anfang beim Einlesen der Pakete mitgeteilt, gerät aber leicht in Vergessenheit und kann zu sehr kryptischen Fehlermeldungen führen.</p>
<p>Wir wollen das kurz anhand der beiden Pakete <code>dplyr</code> und <code>plm</code> illustrieren:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(dplyr)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(plm)</code></pre></div>
<pre><code>#&gt; 
#&gt; Attaching package: &#39;plm&#39;</code></pre>
<pre><code>#&gt; The following objects are masked from &#39;package:dplyr&#39;:
#&gt; 
#&gt;     between, lag, lead</code></pre>
<pre><code>#&gt; The following object is masked from &#39;package:data.table&#39;:
#&gt; 
#&gt;     between</code></pre>
<p>In beiden Paketen gibt es Objekte mit den Namen <code>between</code>, <code>lag</code> und <code>lead</code>. Bei der Verwendung von <code>library</code> maskiert das später eingelesene Paket die Objekte des früheren. Wir können das illustrieren indem wir den Namen des Objekts eingeben:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">lead</code></pre></div>
<pre><code>#&gt; function (x, k = 1, ...) 
#&gt; {
#&gt;     UseMethod(&quot;lead&quot;)
#&gt; }
#&gt; &lt;bytecode: 0x7f8e72137f40&gt;
#&gt; &lt;environment: namespace:plm&gt;</code></pre>
<p>Aus der letzten Zeile wird ersichtlich, dass <code>lead</code> hier aus dem Paket <code>plm</code> kommt.</p>
<p>Wenn wir die Funktion aus <code>dplyr</code> verwenden wollen, müssen wir <code>::</code> verwenden:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dplyr<span class="op">::</span>lead</code></pre></div>
<pre><code>#&gt; function (x, n = 1L, default = NA, order_by = NULL, ...) 
#&gt; {
#&gt;     if (!is.null(order_by)) {
#&gt;         return(with_order(order_by, lead, x, n = n, default = default))
#&gt;     }
#&gt;     if (length(n) != 1 || !is.numeric(n) || n &lt; 0) {
#&gt;         bad_args(&quot;n&quot;, &quot;must be a nonnegative integer scalar, &quot;, 
#&gt;             &quot;not {friendly_type_of(n)} of length {length(n)}&quot;)
#&gt;     }
#&gt;     if (n == 0) 
#&gt;         return(x)
#&gt;     xlen &lt;- length(x)
#&gt;     n &lt;- pmin(n, xlen)
#&gt;     out &lt;- c(x[-seq_len(n)], rep(default, n))
#&gt;     attributes(out) &lt;- attributes(x)
#&gt;     out
#&gt; }
#&gt; &lt;bytecode: 0x7f8e6d2e74f8&gt;
#&gt; &lt;environment: namespace:dplyr&gt;</code></pre>
<p>Wenn es zu Maskierungen kommt ist es aber der Transparenz wegen besser in beiden Fällen <code>::</code> zu verwenden, also <code>plm::lead</code> und <code>dplyr::lead</code>.</p>
<blockquote>
<p><strong>Hinweis</strong>: Alle von Konflikten betroffenen Objekte können mit der Funktion <code>conflicts()</code> angezeigt werden.</p>
</blockquote>
<blockquote>
<p>**Optionale <a href="Info:**" class="uri">Info:**</a> Um zu überprüfen in welcher Reihenfolge R nach Objekten sucht, kann die Funktion <code>search</code> verwendet werden. Wenn ein Objekt aufgerufen wird schaut R zuerst im ersten Element des Vektors nach, der globalen Umgebung. Wenn das Objekt dort nicht gefunden wird, schaut es im zweiten, etc. Wie man hier auch erkennen kann, werden einige Pakete standardmäßig eingelesen. Wenn ein Objekt nirgends gefunden wird gibt R einen Fehler aus. Im vorliegenden Falle zeigt uns die Funktion, dass er erst im Paket <code>nach der Funktion</code> sucht, und nicht im Paket ``:</p>
</blockquote>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">search</span>()</code></pre></div>
<pre><code>#&gt;  [1] &quot;.GlobalEnv&quot;         &quot;package:plm&quot;        &quot;package:dplyr&quot;     
#&gt;  [4] &quot;package:data.table&quot; &quot;package:stats&quot;      &quot;package:graphics&quot;  
#&gt;  [7] &quot;package:grDevices&quot;  &quot;package:utils&quot;      &quot;package:datasets&quot;  
#&gt; [10] &quot;package:methods&quot;    &quot;Autoloads&quot;          &quot;package:base&quot;</code></pre>
<blockquote>
<p><strong>Weiterführender Hinweis</strong> Um das Maskieren besser zu verstehen sollte man sich mit dem Konzept von <em>namespaces</em> und <em>environments</em> auseinandersetzen. Eine gute Erklärung bietet <span class="citation">Wickham and Bryan (<a href="#ref-Packages">2019</a>)</span>.</p>
</blockquote>
<blockquote>
<p><strong>Weiterführender Hinweis</strong> Das Paket <code>conflicted</code> führt dazu, dass R immer einen fehler ausgibt wenn nicht eindeutige Objektnamen verwendet werden.</p>
</blockquote>
</div>
<div id="kurzer-exkurs-zum-einlesen-und-schreiben-von-daten" class="section level2">
<h2><span class="header-section-number">3.6</span> Kurzer Exkurs zum Einlesen und Schreiben von Daten</h2>
<p>Zum Abschluss wollen wir noch kurz einige Befehle zum Einlesen von Daten einführen. Später werden wir uns ein ganzes Kapitel mit dem Einlesen und Schreiben von Daten beschäftigen, da dies in der Regel einen nicht unbeträchtlichen Teil der quantitativen Forschungsarbeit in Anspruch nimmt. An dieser Stelle wollen wir aber nur lernen, wie man einen angemessenen Datensatz in R einliest.</p>
<p>R kann zahlreiche verschiedene Dateiformate einlesen, z.B. <code>csv</code>, <code>dta</code> oder <code>txt</code>, auch wenn für manche Formate bestimmte Libraries geladen sein müssen.</p>
<p>Das gerade für kleinere Datensätze mit Abstand beste Format ist in der Regel <code>csv</code>, da ist von zahlreichen Programmen und auf allen Betriebssystemen gelesen und geschrieben werden kann.</p>
<p>Für die Beispiele hier nehmen wir folgende Ordnerstruktur an:</p>
<pre><code>2019-Methoden
│   2019-Methoden.Rproj
│
+---data
│   │
│   +---raw
│   |    │  Rohdaten.csv
|   |
|   +---tidy</code></pre>
<p>Um die Daten einzulesen verwenden wir das Paket <code>tidyverse</code>, die wir später genauer kennen lernen werden. Sie enthält viele nützliche Funktionen zur Arbeit mit Datensätzen. Zudem verwende ich das Paket <code>here</code> um relative Pfade immer von meinem Arbeitsverzeichnis aus angeben zu können.<a href="#fn12" class="footnoteRef" id="fnref12"><sup>12</sup></a></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(tidyverse)
<span class="kw">library</span>(here)</code></pre></div>
<p>Nehmen wir an, die Datei <code>Rohdaten.csv</code> sähe folgendermaßen aus:</p>
<pre><code>Auto,Verbrauch,Zylinder,PS
Ford Pantera L,15.8,8,264
Ferrari Dino,19.7,6,175
Maserati Bora,15,8,335
Volvo 142E,21.4,4,109</code></pre>
<p>Wie in einer typischen csv Datei sind die Spalten hier mit einem Komma getrennt. Um diese Datei einzulesen verwenden wir die Funktion <code>read_csv</code> mit dem Dateipfad als erstes Argument:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">auto_daten &lt;-<span class="st"> </span><span class="kw">read_csv</span>(<span class="kw">here</span>(<span class="st">&quot;data/raw/Rohdaten.csv&quot;</span>))
auto_daten</code></pre></div>
<pre><code>#&gt; # A tibble: 4 x 4
#&gt;   Auto           Verbrauch Zylinder    PS
#&gt;   &lt;chr&gt;              &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt;
#&gt; 1 Ford Pantera L      15.8        8   264
#&gt; 2 Ferrari Dino        19.7        6   175
#&gt; 3 Maserati Bora       15          8   335
#&gt; 4 Volvo 142E          21.4        4   109</code></pre>
<p>Wir haben nun einen Datensatz in R, mit dem wir dann weitere Analysen anstellen können. Nehmen wir einmal an, wir wollen eine weitere Spalte hinzufügen (Verbrauch/PS) und dann den Datensatz im Ordner <code>data/tidy</code> speichern. Ohne auf die Modifikation des Data Frames einzugehen können wir die Funktion <code>write_csv</code> verwenden um den Datensatz zu speichern. Hierzu geben wir den neuen dataframe als erstes, und den Pfad als zweites Argument an:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">auto_daten_neu &lt;-<span class="st"> </span>auto_daten <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">Verbrauch_pro_PS=</span>Verbrauch<span class="op">/</span>PS)
<span class="kw">write_csv</span>(auto_daten_neu, <span class="kw">here</span>(<span class="st">&quot;data/tidy/NeueDaten.csv&quot;</span>))</code></pre></div>
<p>Es wird ein späteres Kapitel (und einen späteren Vorlesungstermin) geben, in dem wir uns im Detail mit dem Lesen, Schreiben und Manipulieren von Datensätzen beschäftigen.</p>

</div>
</div>



<h3><span class="header-section-number">B</span> Referenzen</h3>
<div id="refs" class="references">
<div id="ref-Packages">
<p>Wickham, Hadley, and Jennifer Bryan. 2019. <em>Advanced R</em>. 2nd ed. Sebastopol, CA: O’Reilly Media. <a href="https://r-pkgs.org/" class="uri">https://r-pkgs.org/</a>.</p>
</div>
</div>
<div class="footnotes">
<hr />
<ol start="2">
<li id="fn2"><p>Theoretisch kann <code>&lt;-</code> auch andersherum verwendet werden: <code>2 + 3 -&gt; zwischenergebnis</code>. Das mag zwar auf den ersten Blick intuitiver erscheinen, da das aus <code>2 + 3</code> resultierende Objekt den Namen <code>zwischenergebnis</code> bekommt, also immer erst das Objekt erstellt wird und dann der Name zugewiesen wird, es führt jedoch zu deutlich weniger lesbarem Code und sollte daher nie verwendet werden. Ebensoweinig sollten Zuweisungen durch den <code>=</code> Operatur vorgenommen werden, auch wenn es im Fall <code>zwischenergebnis = 2 + 3</code> funktionieren würde. Namen <code>zwischenergebnis</code>.<a href="basics.html#fnref2">↩</a></p></li>
<li id="fn3"><p>Wie wir unten lernen werden sind <code>2</code> und <code>3</code> in erster Linie keine Zahlen, sondern Vektoren der Länge 1, und gelten erst in nächster Instanz als ‘Zahl’ (genauer: ‘double’).<a href="basics.html#fnref3">↩</a></p></li>
<li id="fn4"><p>Das liegt daran, dass Funktionen ihr eigenes <a href="https://adv-r.hadley.nz/environments.html">environment</a> haben.<a href="basics.html#fnref4">↩</a></p></li>
<li id="fn5"><p>Das ist strikt genommen nicht notwendig, aber der Übersichtlichkeit werden wir immer <code>return</code> verwenden. Eine interessante Debatte darüber ob man <code>return</code> verwenden sollte oder nicht findet sich <a href="https://stackoverflow.com/questions/11738823/explicitly-calling-return-in-a-function-or-not">hier</a>.<a href="basics.html#fnref5">↩</a></p></li>
<li id="fn6"><p>Diese auf den ersten Blick merkwürdige Syntax hat historische Gründe: als der integer Typ in die R Programmiersprache eingeführt wurde war er sehr stark an den Typ <code>long integer</code> in der Programmiersprache ‘C’ angelehnt. In C wurde ein solcher ‘long integer’ mit dem Suffix ‘l’ oder ‘L’ definiert, diese Regel wurde aus Kompatibilitätsgründen auch für R übernommen, jedoch nur mit ‘L’, da man Angst hatte, dass ‘l’ mit ‘i’ verwechselt wird, was in R für die imaginäre Komponente komplexer Zahlen verwendet wird.<a href="basics.html#fnref6">↩</a></p></li>
<li id="fn7"><p>Für viele typische Aufgaben gibt es in R bereits eine vordefinierte Funktion. Am einfachsten findet man diese durch schlichtes Googlen.<a href="basics.html#fnref7">↩</a></p></li>
<li id="fn8"><p>Gerade bei sehr großen Data Frames möchte man oft nur die ersten paar Elemente inspizieren. Das ist mit der Funktion <code>head()</code> möglich.<a href="basics.html#fnref8">↩</a></p></li>
<li id="fn9"><p>Zur Geschichte dieses wirklich ärgerlichen Verhaltens siehe <a href="https://simplystatistics.org/2015/07/24/stringsasfactors-an-unauthorized-biography/">diesen Blog</a>.<a href="basics.html#fnref9">↩</a></p></li>
<li id="fn10"><p>Das ist nicht ganz korrekt, weil es mittlerweilse Erweiterungen gibt, welche den <code>data.frame</code> mit effizienteren Objekten ersetzen, z.B. dem <code>tibble</code> oder dem <code>data.table</code>. Der Umgang mit diesen Objekten ist jedoch sehr ähnlich zum <code>data.frame</code>.<a href="basics.html#fnref10">↩</a></p></li>
<li id="fn11"><p><span class="citation">Wickham and Bryan (<a href="#ref-Packages">2019</a>)</span> bietet eine exzellente Einführung in das Programmieren von R Paketen.<a href="basics.html#fnref11">↩</a></p></li>
<li id="fn12"><p>Das ist notwendig, da dieses Skript in R Markdown geschrieben ist und das Arbeitsverzeichnis automatisch auf den Ordner ändert, in dem das .Rmd file liegt. Mehr Information zum Schreiben von R Markdown finden Sie im Anhang. Dieser wird auch in der Vorlesung besprochen.<a href="basics.html#fnref12">↩</a></p></li>
</ol>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="einrichtung.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="markdown.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"history": {
"link": null,
"text": null
},
"download": ["R-SocioEcon-dt.pdf"],
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
